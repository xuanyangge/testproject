"use strict";
/** Storage implementation is very simple: uses an array indexed
    by order of declaration. Cloning an array is very fast, see:
    https://github.com/facebook/immutable-js/issues/286
*/
function makeDoopDescriptor(index, target, key) {
    var original = target[key];
    var defaultValue;
    // This implements the getter/setter for each Doop property
    function Doop(val) {
        if (arguments.length == 0) {
            // Get: this is easy, just fetch from our secret array
            var val_1 = this.$__Doop__$ && this.$__Doop__$[index];
            return (val_1 === undefined) ? defaultValue : val_1;
        }
        // Set: first make sure our secret array exists
        if (!this.$__Doop__$) {
            this.$__Doop__$ = [];
        }
        // While running inside constructor, just mutate the value
        if (this.$__Doop__$Constructing) {
            this.$__Doop__$[index] = val;
            // And return the same (albeit mutated) instance
            return this;
        }
        // Make a new instance based on prototype
        var revision = Object.create(target);
        // Copy the secret array from the original object
        var copy = revision.$__Doop__$ = this.$__Doop__$.slice(0);
        // Mutate the new secret array
        copy[index] = val;
        // Return the mutated clone
        return revision;
    }
    var mapper = original && original.$__Doop__$Mapper;
    var isField = original && original.$__Doop__$Field;
    var reducers;
    if (mapper || isField) {
        reducers = target.$__Doop__$Reducers;
        if (isField) {
            defaultValue = original.$__Doop__$Init;
            Doop.$__Doop__$Field = true;
            Doop.$__Doop__$Init = original.$__Doop__$Init;
        }
        Doop.self = function (container) {
            return cursor(container()[key](), function (action) { return container({
                type: key + ".self",
                payload: action,
                $: undefined
            }); });
        };
        reducers[key + ".self"] = function (container, childAction) {
            var child = container[key]();
            var reduce = child.$__Doop__$Reduce;
            if (reduce) {
                var newChild = reduce(child, childAction);
                return container[key](newChild);
            }
            return container;
        };
    }
    if (mapper) {
        defaultValue = mapper.empty;
        Doop.$__Doop__$Mapper = mapper;
        var defaultItem_1 = Doop.$__Doop__$DefaultItem = original.$__Doop__$DefaultItem;
        Doop.item = function (container, address) {
            var val = mapper.get(container()[key](), address);
            return cursor(val === undefined ? defaultItem_1 : val, function (itemAction) {
                container({
                    type: key + ".item",
                    payload: { address: address, itemAction: itemAction },
                    $: undefined
                });
            });
        };
        Doop.remove = function (address) {
            return {
                type: key + ".item",
                payload: { address: address, undefined: undefined },
                $: undefined
            };
        };
        reducers[key + ".item"] = function (container, _a) {
            var address = _a.address, itemAction = _a.itemAction;
            var collection = container[key]();
            var item = mapper.get(collection, address);
            var defaulted = item === undefined ? defaultItem_1 : item;
            var reduce = defaulted.$__Doop__$Reduce;
            if (reduce) {
                var newItem = itemAction === undefined ? undefined : reduce(defaulted, itemAction);
                var newCollection = mapper.set(collection, address, newItem);
                return container[key](newCollection);
            }
            return container;
        };
    }
    return {
        writable: true,
        enumerable: true,
        configurable: true,
        value: Doop
    };
}
function clone(obj) {
    return obj && JSON.parse(JSON.stringify(obj));
}
function assign(target, source) {
    Object.keys(source).forEach(function (key) {
        target[key] = source[key];
    });
    return target;
}
function doop(target, propertyKey, descriptor) {
    if (!target) {
        // We're being used to declare the property
        return undefined;
    }
    if (!propertyKey) {
        var wrapper_1 = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            // During construction, set the flag so Doop setters can mutate
            this.$__Doop__$Constructing = (this.$__Doop__$Constructing || 0) + 1;
            try {
                target.apply(this, args);
            }
            finally {
                this.$__Doop__$Constructing--;
            }
            return this;
        };
        var prototype_1 = wrapper_1.prototype = target.prototype;
        prototype_1.$__Doop__$Reducers = {};
        Object.keys(target).forEach(function (key) {
            var staticField = target[key];
            if (staticField && staticField.$__Doop__$ActionName) {
                staticField = staticField.$__Doop__$ActionName(key);
                if (staticField.$__Doop__$Reducer) {
                    prototype_1.$__Doop__$Reducers[key] = staticField.$__Doop__$Reducer;
                }
            }
            wrapper_1[key] = staticField;
        });
        var indices_1 = prototype_1.$__Doop__$Indices = clone(prototype_1.$__Doop__$Indices);
        if (indices_1) {
            /** Redefine inherited Doop properties. Why? See makeDoopDescriptor.
                when the user sets a property we clone the object, which starts
                with giving the prototype to Object.create. This better not be
                the base class's prototype, or we'll get an instance of the base
                class. So we just create new definitions at every level of
                inheritance.
            */
            for (var _i = 0, _a = Object.keys(indices_1); _i < _a.length; _i++) {
                var key = _a[_i];
                Object.defineProperty(prototype_1, key, makeDoopDescriptor(indices_1[key], prototype_1, key));
            }
        }
        prototype_1.$__Doop__$Reduce = function (state, action) {
            var reduce = prototype_1.$__Doop__$Reducers[action.type];
            return reduce ? reduce(state, action.payload) : state;
        };
        prototype_1.toJSON = function () {
            var obj = {};
            for (var _i = 0, _a = Object.keys(indices_1); _i < _a.length; _i++) {
                var key = _a[_i];
                obj[key] = this[key]();
            }
            return obj;
        };
        return wrapper_1;
    }
    // Allocate an index on this type
    var index = target.$__Doop__$Count || 0;
    target.$__Doop__$Count = index + 1;
    // Create the indices map so we can redefine properties in inheriting classes
    var indices = target.$__Doop__$Indices || (target.$__Doop__$Indices = {});
    indices[propertyKey] = index;
}
exports.doop = doop;
function makeAction(name, reduce) {
    var func = function (payload) {
        return { type: name, payload: payload, $: undefined };
    };
    var merged;
    merged = assign(func, {
        $__Doop__$ActionName: function (newName) {
            return newName === name ? merged : makeAction(newName, reduce);
        },
        $__Doop__$Reducer: reduce
    });
    return merged;
}
function action(reduce) {
    return makeAction("(noname)", reduce);
}
exports.action = action;
function cursor(snapshot, dispatch) {
    return function (action) {
        if (action) {
            dispatch(action);
        }
        return snapshot;
    };
}
function arraySet(array, index, value) {
    var clone = array.slice(0);
    clone[index] = value;
    return clone;
}
exports.arraySet = arraySet;
exports.arrayMapper = {
    empty: [],
    get: function (array, index) { return array[index]; },
    set: arraySet
};
function merge(first, second) {
    return assign(assign({}, first), second);
}
exports.merge = merge;
var objectMapper = {
    empty: {},
    get: function (obj, key) { return obj[key]; },
    set: function (obj, key, value) {
        if (value === undefined) {
            var clone = assign({}, obj);
            delete clone[key];
            return clone;
        }
        return merge(obj, (_a = {}, _a[key] = value, _a));
        var _a;
    }
};
exports.objectMapperString = objectMapper;
exports.objectMapperNumber = objectMapper;
function field(init) {
    // posts actions using field name
    return { $__Doop__$Field: true, $__Doop__$Init: init };
}
exports.field = field;
function collection(mapper, defaultItem) {
    // posts actions that include the address in the payload
    return {
        $__Doop__$Mapper: mapper,
        $__Doop__$DefaultItem: defaultItem
    };
}
exports.collection = collection;
function createReducer(init) {
    return function (state, action) {
        if (!state) {
            return init;
        }
        var reducer = state.$__Doop__$Reduce;
        if (reducer) {
            return reducer(state, action);
        }
        return state;
    };
}
exports.createReducer = createReducer;
function createStore(init) {
    var reducer = createReducer(init);
    var subscribers = [];
    var state = reducer(undefined, { type: "$__Doop__$initAction" });
    ;
    function dispatch(action) {
        var newState = reducer(state, action);
        if (newState !== state) {
            state = newState;
            subscribers.forEach(function (s) { return s(); });
        }
    }
    return {
        cursor: function () {
            return cursor(state, dispatch);
        },
        subscribe: function (handler) {
            subscribers.push(handler);
            return function () {
                var index = subscribers.indexOf(handler);
                if (index !== -1) {
                    subscribers.splice(index);
                }
            };
        }
    };
}
exports.createStore = createStore;
function cursorFromStore(store) {
    return cursor(store.getState(), store.dispatch);
}
exports.cursorFromStore = cursorFromStore;
//# sourceMappingURL=doop.js.map