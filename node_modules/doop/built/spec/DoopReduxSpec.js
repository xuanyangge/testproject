"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var doop_1 = require("../doop");
var Doop = require("../doop");
var Publisher = (function () {
    function Publisher() {
    }
    Object.defineProperty(Publisher.prototype, "name", {
        get: function () { return Doop.field(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Publisher.prototype, "reputation", {
        get: function () { return Doop.field(3); },
        enumerable: true,
        configurable: true
    });
    Publisher.upvote = Doop.action(function (pub) { return pub.reputation(Math.min(5, pub.reputation() + 1)); });
    Publisher.downvote = Doop.action(function (pub) { return pub.reputation(Math.max(1, pub.reputation() - 1)); });
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Publisher.prototype, "name", null);
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Publisher.prototype, "reputation", null);
    Publisher = __decorate([
        doop_1.doop, 
        __metadata('design:paramtypes', [])
    ], Publisher);
    return Publisher;
}());
var ForeignPublisher = (function (_super) {
    __extends(ForeignPublisher, _super);
    function ForeignPublisher() {
        _super.apply(this, arguments);
    }
    ForeignPublisher.upvote = Publisher.downvote;
    ForeignPublisher.downvote = Publisher.upvote;
    ForeignPublisher = __decorate([
        doop_1.doop, 
        __metadata('design:paramtypes', [])
    ], ForeignPublisher);
    return ForeignPublisher;
}(Publisher));
var Book = (function () {
    function Book() {
    }
    Object.defineProperty(Book.prototype, "title", {
        get: function () { return Doop.field(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Book.prototype, "price", {
        get: function () { return Doop.field(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Book.prototype, "publisher", {
        get: function () { return Doop.field(new Publisher()); },
        enumerable: true,
        configurable: true
    });
    Book.setTitleAndPrice = Doop.action(function (book, _a) {
        var title = _a.title, price = _a.price;
        return book.title(title).price(price);
    });
    Book.publish = Doop.action(function (book, name) { return book.publisher(new Publisher().name(name)); });
    Book.publishOverseas = Doop.action(function (book, name) { return book.publisher(new ForeignPublisher().name(name)); });
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Book.prototype, "title", null);
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Book.prototype, "price", null);
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Book.prototype, "publisher", null);
    Book = __decorate([
        doop_1.doop, 
        __metadata('design:paramtypes', [])
    ], Book);
    return Book;
}());
var Shelf = (function () {
    function Shelf() {
        // NB. don't need to initialise collections
    }
    Object.defineProperty(Shelf.prototype, "books", {
        get: function () {
            return Doop.collection(Doop.objectMapperNumber);
        },
        enumerable: true,
        configurable: true
    });
    Shelf.addBook = Doop.action(function (shelf, id) { return shelf.books(Doop.merge(shelf.books(), (_a = {}, _a[id] = new Book(), _a))); var _a; });
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Shelf.prototype, "books", null);
    Shelf = __decorate([
        doop_1.doop, 
        __metadata('design:paramtypes', [])
    ], Shelf);
    return Shelf;
}());
var enableLogging = true;
function log(message, data) {
    if (!enableLogging) {
        return;
    }
    console.log("--------------- " + message + " ---------------");
    console.log(JSON.stringify(data, null, 4));
}
function createTestStore(init) {
    var store = Doop.createStore(init);
    store.subscribe(function () {
        log("changed", store.cursor()());
    });
    return store;
}
describe("doop", function () {
    it("supports a basic test of setup", function () {
        var root = createTestStore(new Shelf());
        root.cursor()(Shelf.addBook(8001));
        var firstBook = root.cursor()().books.item(root.cursor(), 8001);
        firstBook(Book.setTitleAndPrice({ title: "1985", price: 2.99 }));
        firstBook(Book.publish("Penguin"));
        var firstBookPublisher = firstBook().publisher.self(firstBook);
        expect(firstBookPublisher().reputation()).toEqual(3);
        firstBookPublisher(Publisher.upvote());
        var rc1 = root.cursor();
        expect(rc1().books()[8001].price()).toEqual(2.99);
        expect(rc1().books()[8001].publisher().name()).toEqual("Penguin");
        expect(rc1().books()[8001].publisher().reputation()).toEqual(4);
        // Sets new ForeignPublisher, reputation back to 3
        firstBook(Book.publishOverseas("Der Schtumphenpressen"));
        // Upvote is now downward!
        firstBookPublisher(Publisher.upvote());
        var rc2 = root.cursor();
        expect(rc2().books()[8001].publisher().name()).toEqual("Der Schtumphenpressen");
        expect(rc2().books()[8001].publisher().reputation()).toEqual(2);
    });
});
var Node = (function () {
    function Node() {
    }
    Object.defineProperty(Node.prototype, "value", {
        get: function () { return Doop.field(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "children", {
        get: function () {
            return Doop.collection(Doop.objectMapperString, new Node());
        },
        enumerable: true,
        configurable: true
    });
    Node.SetValue = Doop.action(function (node, value) { return node.value(value); });
    Node.bindPath = function (cursor, _a) {
        var head = _a[0], tail = _a.slice(1);
        return head === undefined ? cursor : Node.bindPath(cursor().children.item(cursor, head), tail);
    };
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Node.prototype, "value", null);
    __decorate([
        doop_1.doop, 
        __metadata('design:type', Object)
    ], Node.prototype, "children", null);
    Node = __decorate([
        doop_1.doop, 
        __metadata('design:paramtypes', [])
    ], Node);
    return Node;
}());
/* Known issue: due to order in which TS runs decorators vs static initializers
@doop
class StaticInit {

    @doop
    get something() { return Doop.field<number, this>() }

    static Test = new StaticInit().something(5);
}
*/
describe("doop", function () {
    /*
        it("allows static members to instantiate itself", () => {
    
           expect(StaticInit.Test.something()).toEqual(5);
        });
    */
    it("supports creation on demand", function () {
        var store = createTestStore(new Node());
        // We can bind to a path in a single operation, without making any updates yet
        var z1 = Node.bindPath(store.cursor(), ["x", "y", "z"]);
        // Send an action to the cursor, the whole path is created now
        z1(Node.SetValue("p"));
        // Re-bind so we can see the update
        var z2 = Node.bindPath(store.cursor(), ["x", "y", "z"]);
        expect(z2().value()).toEqual("p");
        // Also a built-in action to remove from the collection (depending on the
        // mapper used, it might just store an undefined in the slot).
        var y1 = Node.bindPath(store.cursor(), ["x", "y"]);
        y1(y1().children.remove("z"));
        expect(JSON.stringify(store.cursor()())).toEqual("{\"children\":{\"x\":{\"children\":{\"y\":{\"children\":{}}}}}}");
    });
});
//# sourceMappingURL=DoopReduxSpec.js.map