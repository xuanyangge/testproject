/** This overload is used in property declarations. Maybe prefer 'field 'as it
    supports supplying an initial value.
*/
export declare function doop<V, O>(): Doop<V, O>;
/** This overload acts as a decorator on a class, indicating that it is
    immutable.
*/
export declare function doop(target: any): any;
/** This overload acts as a decorator on a property getter, and converts it into
    an ordinary function which (this is the beautiful hack) is syntactically
    compatible with a getter that returns the Doop interface.
*/
export declare function doop(target: any, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): TypedPropertyDescriptor<any> | void;
/** As far as TypeScript is concerned, a Doop property is a getter that returns
    an instance of some object that supports this interface.

    But at runtime we reconfigure it to be an ordinary function that implements
    this interface directly, so that `this` refers to the owner object.
*/
export interface Doop<V, O> {
    (): V;
    (newValue: V): O;
}
/**
 * An action that can be sent to a cursor (or Redux store)
 */
export interface Action<Target, Payload> {
    type: string;
    payload: Payload;
    $: Target;
}
export declare function action<Payload, State>(reduce: (state: State, payload: Payload) => State): (payload: Payload) => Action<State, Payload>;
export declare function action<State>(reduce: (state: State) => State): () => Action<State, void>;
export interface Cursor<State> {
    (): State;
    (action: Action<State, any>): void;
}
export interface Mapper<Item, Collection, Address> {
    readonly empty: Collection;
    get(container: Collection, address: Address): Item;
    set(container: Collection, address: Address, value: Item): Collection;
}
export declare function arraySet<T>(array: T[], index: number, value: T): T[];
export declare const arrayMapper: Mapper<any, any[], number>;
export declare function merge<Target, Source>(first: Target, second: Source): Target & Source;
export declare const objectMapperString: Mapper<any, {
    [name: string]: any;
}, string>;
export declare const objectMapperNumber: Mapper<any, {
    [name: number]: any;
}, number>;
export interface Field<Type, Container> extends Doop<Type, Container> {
    self(container: Cursor<Container>): Cursor<Type>;
}
export declare function field<Type, Container>(init?: Type): Field<Type, Container>;
export interface CollectionField<Item, Collection, Address, Container> extends Field<Collection, Container> {
    item(container: Cursor<Container>, address: Address): Cursor<Item>;
    remove(address: Address): Action<Container, Address>;
}
export declare function collection<Item, Collection, Address, Container>(mapper: Mapper<Item, Collection, Address>, defaultItem?: Item): CollectionField<Item, Collection, Address, Container>;
export declare function createReducer<State>(init: State): (state: State, action: Action<State, any>) => State;
export interface CommonStore<State> {
    subscribe(handler: () => void): {
        (): void;
    };
}
export interface SimpleStore<State> extends CommonStore<State> {
    cursor(): Cursor<State>;
}
export declare function createStore<State>(init: State): SimpleStore<State>;
export interface ReduxStore<State> extends CommonStore<State> {
    getState(): State;
    dispatch(action: Action<State, any>): void;
}
export declare function cursorFromStore<State>(store: ReduxStore<State>): Cursor<State>;
